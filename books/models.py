from decimal import Decimal
import datetime

from django.db import models
from django.core.validators import MinValueValidator, RegexValidator
from django.core.exceptions import ValidationError
from django.utils import timezone
from django.utils.text import slugify
from django.utils.translation import gettext_lazy as _


class SoftDeleteModel(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(deleted_at__isnull=True)

    def all_with_deleted(self):
        return super().get_queryset().all()


class TimeStampedModel(models.Model):
    """
    Abstract model that provides created_at and updated_at timestamps.
    """
    created_at = models.DateTimeField(auto_now_add=True, verbose_name=_("Created at"))
    updated_at = models.DateTimeField(auto_now=True, verbose_name=_("Updated at"))

    class Meta:
        abstract = True


class Author(TimeStampedModel):
    first_name = models.CharField(max_length=50, verbose_name=_("First name"), help_text=_("Given name"))
    last_name = models.CharField(max_length=50, db_index=True, verbose_name=_("Last name"), help_text=_("Family name"))
    birth_date = models.DateField(null=True, blank=True, verbose_name=_("Birth date"))
    biography = models.TextField(blank=True, verbose_name=_("Biography"))

    class Meta:
        verbose_name = _("Author")
        verbose_name_plural = _("Authors")
        ordering = ["last_name", "first_name"]
        indexes = [
            models.Index(fields=["last_name", "first_name"]),
        ]

    def __str__(self) -> str:
        return f"{self.first_name} {self.last_name}"

    @property
    def full_name(self) -> str:
        return str(self)



class Publisher(TimeStampedModel):  # models.Model
    name = models.CharField(max_length=150, unique=True, db_index=True, verbose_name=_("Name"))
    established_date = models.DateField(null=True, blank=True, verbose_name=_("Established date"))
    website = models.URLField(blank=True, verbose_name=_("Website"))
    deleted_at = models.DateField(null=True, blank=True, verbose_name=_("Deleted date"))

    objects = SoftDeleteModel()

    class Meta:
        verbose_name = _("Publisher")
        verbose_name_plural = _("Publishers")
        ordering = ["name"]

    def delete(self, *args, **kwargs):
        self.deleted_at = timezone.now()
        self.save(update_fields=["deleted_at"])

    def __str__(self) -> str:
        return self.name


class Book(TimeStampedModel):
    title = models.CharField(max_length=255, db_index=True, verbose_name=_("Title"))
    subtitle = models.CharField(max_length=255, blank=True, verbose_name=_("Subtitle"))
    slug = models.SlugField(max_length=255, unique=True, blank=True, verbose_name=_("Slug"),
                            help_text=_("URL friendly identifier; autogenerated from title if empty"))
    publisher = models.ForeignKey(
        Publisher,
        on_delete=models.PROTECT,
        related_name="books",
        verbose_name=_("Publisher")
    )
    published_date = models.DateField(null=True, blank=True, verbose_name=_("Published date"))

    isbn_validator = RegexValidator(
        regex=r'^(97(8|9))?\d{9}(\d|X)$',
        message=_("Enter a valid ISBN-10 or ISBN-13 (digits or X).")
    )
    isbn = models.CharField(max_length=17, blank=True, null=True, validators=[isbn_validator], verbose_name=_("ISBN"),
                            help_text=_("ISBN-10 or ISBN-13, numbers only (or trailing X)"))
    price = models.DecimalField(
        max_digits=10, decimal_places=2, null=True, blank=True,
        validators=[MinValueValidator(0)],
        verbose_name=_("Price")
    )
    discounted_price = models.DecimalField(
        max_digits=10, decimal_places=2, null=True, blank=True,
        validators=[MinValueValidator(0)],
        verbose_name=_("Discounted price"),
        help_text=_("If provided, must be less than or equal to price")
    )
    is_bestseller = models.BooleanField(default=False, verbose_name=_("Is bestseller"))

    authors = models.ManyToManyField(
        Author,
        through="BookAuthor",
        related_name="books",
        verbose_name=_("Authors")
    )
    is_banned = models.BooleanField(default=False, verbose_name=_("Is banned"))

    class Meta:
        verbose_name = _("Book")
        verbose_name_plural = _("Books")
        ordering = ["-published_date", "title"]
        indexes = [
            models.Index(fields=["title"]),
            models.Index(fields=["isbn"]),
        ]

    def __str__(self) -> str:
        return self.title

    def clean(self):
        # Validate discounted_price <= price when both are present
        errors = {}
        if self.price is not None and self.discounted_price is not None:
            try:
                if Decimal(self.discounted_price) > Decimal(self.price):
                    errors["discounted_price"] = ValidationError(
                        _("Discounted price cannot be greater than price.")
                    )
            except:
                errors["discounted_price"] = ValidationError(_("Invalid price values."))

        # Prevent obviously wrong published_date (optional — comment out if preorders allowed)
        if self.published_date and self.published_date > datetime.date.today():
            # it's common to allow future publication (preorders), so this check is optional.
            # if you want to allow future dates, remove this block.
            errors["published_date"] = ValidationError(_("Published date cannot be in the future."))

        if errors:
            raise ValidationError(errors)

    def save(self, *args, **kwargs):
        # auto-generate unique slug from title if not provided
        if not self.slug and self.title:
            base = slugify(self.title)[:200] or "book"
            slug = base
            n = 1
            while Book.objects.filter(slug=slug).exclude(pk=self.pk).exists():
                n += 1
                slug = f"{base}-{n}"
            self.slug = slug
        super().save(*args, **kwargs)

    @property
    def has_discount(self) -> bool:
        return (self.discounted_price is not None) and (self.price is not None) and (self.discounted_price < self.price)

    @property
    def current_price(self):
        return self.discounted_price if self.has_discount else self.price


class BookAuthor(models.Model):
    """
    Through model between Book and Author storing role and order.
    """

    class Role(models.TextChoices):
        AUTHOR = "author", _("Author")
        COAUTHOR = "coauthor", _("Co-author")
        EDITOR = "editor", _("Editor")
        TRANSLATOR = "translator", _("Translator")

    book = models.ForeignKey(Book, on_delete=models.CASCADE, verbose_name=_("Book"))
    author = models.ForeignKey(Author, on_delete=models.CASCADE, verbose_name=_("Author"))
    role = models.CharField(max_length=20, choices=Role.choices, default=Role.AUTHOR, verbose_name=_("Role"))
    order = models.PositiveIntegerField(default=1, verbose_name=_("Order"),
                                        help_text=_("Author display order; 1 = first"))

    class Meta:
        verbose_name = _("Book author")
        verbose_name_plural = _("Book authors")
        ordering = ["order"]
        indexes = [
            models.Index(fields=["book", "author"]),
        ]

    def __str__(self) -> str:
        return f"{self.author} — {self.get_role_display()} «{self.book}»"
